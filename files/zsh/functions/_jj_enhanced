#compdef jj

# Enhanced jj completion with config alias support and smart revision completion

# Load and save original _jj
if (( ! $+functions[_jj_original] )); then
  builtin autoload -Uz +X _jj
  functions[_jj_original]="$functions[_jj]"
fi

# Completion function for jj bookmarks (for bookmark management commands)
# Shows all bookmarks including remotes
_jj_bookmarks() {
  local -a bookmarks

  local current_bookmark
  while IFS= read -r line; do
    if [[ "$line" =~ ^[^[:space:]] ]]; then
      # Local bookmark (not indented)
      current_bookmark="${line%%:*}"
      bookmarks+=("${current_bookmark}:local bookmark")
    elif [[ "$line" =~ ^[[:space:]]+@([^:[:space:]]+) ]]; then
      # Remote bookmark (indented, starts with @)
      local remote="${match[1]}"
      bookmarks+=("${current_bookmark}@${remote}:remote bookmark")
    fi
  done < <(jj bookmark list --all-remotes 2>/dev/null)

  _describe -t bookmarks 'bookmarks' bookmarks
}

# Completion function for jj revisions/revsets
# Only shows bookmarks visible in default log (not all bookmarks)
_jj_revisions() {
  local -a revisions

  # Add common revision expressions (always valid)
  local -a common_revs=(
    '@:working copy'
    '@-:parent of working copy'
    '@--:grandparent of working copy'
  )
  revisions+=("${common_revs[@]}")

  # Parse change IDs, commit IDs, and bookmarks from log output
  # Use the default log output (respects user's default revset)
  # This will only include bookmarks that are visible in the default log
  local line change_id commit_id desc bookmarks_str
  while IFS= read -r line; do
    # Skip empty lines
    [[ -z "$line" ]] && continue
    # Parse format: "change_id|commit_id|bookmarks|description"
    # Using | as delimiter to avoid parsing issues
    local -a parts
    parts=("${(@s:|:)line}")

    change_id="${parts[1]}"
    commit_id="${parts[2]}"
    bookmarks_str="${parts[3]}"
    desc="${parts[4]:-}"

    # Skip if no change_id or commit_id
    [[ -z "$change_id" || -z "$commit_id" ]] && continue

    # Use "(empty)" for commits without descriptions
    [[ -z "$desc" ]] && desc="(empty)"
    # Truncate description if too long
    [[ ${#desc} -gt 50 ]] && desc="${desc:0:47}..."

    # Parse bookmarks (space-separated list)
    if [[ -n "$bookmarks_str" ]]; then
      # Split on space to get individual bookmarks
      local -a bookmark_list
      bookmark_list=("${(@s: :)bookmarks_str}")
      for bookmark in "${bookmark_list[@]}"; do
        # Skip empty bookmarks
        [[ -z "$bookmark" ]] && continue
        # Remove the * suffix if present (indicates current bookmark)
        local clean_bookmark="${bookmark%\*}"
        # Only add the clean version without * suffix
        revisions+=("${clean_bookmark}:${desc}")
      done
    fi

    # Add change ID (short form) with description
    revisions+=("${change_id}:${desc}")
    # Add commit ID (git SHA, short form) with description
    revisions+=("${commit_id}:${desc}")
  done < <(jj log --no-graph --color=never -T 'change_id.short() ++ "|" ++ commit_id.short() ++ "|" ++ bookmarks ++ "|" ++ description.first_line() ++ "\n"' 2>/dev/null)

  _describe -t revisions 'revisions' revisions
}

# No-op completion function for NAME arguments (bookmark names, tag names, etc.)
# These shouldn't complete to files
_jj_no_completion() {
  # Offer no completions
  return 1
}

# Parse jj config aliases
typeset -gA _jj_config_aliases _jj_config_alias_map

_jj_parse_config_aliases() {
  [[ -n "$_jj_aliases_cached" ]] && return

  # Cache file for parsed aliases (shared with shell alias generation)
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/zsh"
  local cache_file="$cache_dir/jj-aliases-parsed.cache"
  local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/jj/config.toml"

  # Check if cache is valid
  local use_cache=0
  if [[ -f "$cache_file" ]]; then
    if [[ -f "$config_file" ]]; then
      [[ "$cache_file" -nt "$config_file" ]] && use_cache=1
    else
      use_cache=1
    fi
  fi

  if (( use_cache )); then
    # Load from cache
    # Format: alias_name|full_expansion|first_word
    local line alias_name full_expansion first_word
    while IFS='|' read -r alias_name full_expansion first_word; do
      [[ -z "$alias_name" ]] && continue
      _jj_config_aliases[$alias_name]="$full_expansion"
      _jj_config_alias_map[$alias_name]="$first_word"
    done < "$cache_file"
  else
    # Parse and cache
    [[ ! -d "$cache_dir" ]] && mkdir -p "$cache_dir"
    : > "$cache_file"

    local alias_name alias_value
    while IFS='=' read -r alias_name alias_value; do
      [[ -z "$alias_name" ]] && continue
      alias_value="${alias_value#\[}"
      alias_value="${alias_value%\]}"
      local -a parts
      parts=("${(@s:, :)alias_value}")
      parts=("${parts[@]//\"/}")
      local full_expansion="${(j: :)parts}"
      local first_word="${parts[1]}"

      _jj_config_aliases[$alias_name]="$full_expansion"
      _jj_config_alias_map[$alias_name]="$first_word"

      # Save to cache
      echo "${alias_name}|${full_expansion}|${first_word}" >> "$cache_file"
    done < <(jj aliases 2>/dev/null)
  fi

  _jj_aliases_cached=1
}

# Wrapper for _jj_commands to add config aliases
_jj_commands() {
  # First let the original _jj define _jj_commands if it exists in _jj_original
  # We'll temporarily save our wrapper and restore the original behavior
  local saved_func="$functions[_jj_commands]"
  unfunction _jj_commands 2>/dev/null

  # Call a subshell to get the commands from the original completion
  # This extracts the command definitions that _jj would normally provide
  local -a base_commands
  base_commands=("${(@f)$(jj --help 2>/dev/null | sed -n '/^Commands:/,/^$/p' | tail -n +2 | sed 's/^  \([a-z-]*\)  */\1:/' | sed 's/  *$//')}")

  local -a commands
  commands=("${base_commands[@]}")

  # Restore our wrapper
  functions[_jj_commands]="$saved_func"

  # Add config aliases
  _jj_parse_config_aliases
  local alias_name full_cmd
  for alias_name full_cmd in ${(kv)_jj_config_aliases}; do
    [[ "$alias_name" == "aliases" ]] && continue
    commands+=("${alias_name}:config alias for: ${full_cmd}")
  done

  _describe -t commands 'jj commands' commands "$@"
}

# Main wrapper
_jj() {
  _jj_parse_config_aliases

  # If the second word is a config alias, we need to handle it specially
  # This makes `jj bm <tab>` complete like `jj bookmark move <tab>`
  if (( CURRENT >= 2 )) && (( $+_jj_config_aliases[$words[2]] )); then
    # Get the full alias expansion (e.g., "bookmark move" for "bm")
    local expansion="${_jj_config_aliases[$words[2]]}"
    local -a expansion_parts
    expansion_parts=("${(@s: :)expansion}")

    # Replace the alias in $words with its expansion
    # Original: (jj bm arg1 arg2)
    # Becomes: (jj bookmark move arg1 arg2)
    local -a new_words
    new_words=("$words[1]")
    new_words+=("${expansion_parts[@]}")
    if (( ${#words} > 2 )); then
      new_words+=("${words[@]:2}")
    fi

    # Calculate the new CURRENT position
    local new_current
    if (( CURRENT == 2 )); then
      # Completing the alias itself - stay at position 2
      new_current=2
    else
      # After the alias - shift position by (expansion_length - 1)
      new_current=$((CURRENT + ${#expansion_parts} - 1))
    fi

    # Set up new context
    words=("${new_words[@]}")
    CURRENT=$new_current

    # Call the patched original completion
    # _jj_original defines the inner _jj function but doesn't call it
    # because $funcstack[1] is "_jj" not "_jj_original"
    # So we need to call it to set up the functions, then call the inner _jj

    # First, save our wrapper so we can temporarily undefine it
    local saved_wrapper="${functions[_jj]}"
    unfunction _jj

    # Call _jj_original to define the inner _jj and helpers
    _jj_original "$@"

    # Now call the inner _jj that was just defined
    _jj "$@"
    local ret=$?

    # Restore our wrapper
    functions[_jj]="$saved_wrapper"

    return $ret
  fi

  # Call patched original completion
  local saved_wrapper="${functions[_jj]}"
  unfunction _jj

  _jj_original "$@"
  _jj "$@"
  local ret=$?

  functions[_jj]="$saved_wrapper"

  return $ret
}
